import{j as d,D as N,K as P,k as j,L as l,M as x,N as S,i as v,O as L,J as _,P as O,Q as c,R as y,S as w,U as T,V as A,n as h,W as R,X as B,Y as E,Z as M}from"./Ys5eufZ_.js";const g=B,C=d({name:"LayoutLoader",inheritAttrs:!1,props:{name:String,layoutProps:Object},setup(e,s){return()=>y(l[e.name],e.layoutProps,s.slots)}}),H={name:{type:[String,Boolean,Object],default:null},fallback:{type:[String,Object],default:null}},q=d({name:"NuxtLayout",inheritAttrs:!1,props:H,setup(e,s){const t=N(),u=v(c),o=!u||u===P()?L():u,a=_(()=>{let n=h(e.name)??o?.meta.layout??g(o?.path).appLayout??"default";return n&&!(n in l)&&e.fallback&&(n=h(e.fallback)),n}),i=O();s.expose({layoutRef:i});const r=t.deferHydration();if(t.isHydrating){const n=t.hooks.hookOnce("app:error",r);j().beforeEach(n)}let p;return()=>{const n=a.value&&a.value in l,f=o?.meta.layoutTransition??x,k=p;return p=a.value,S(n&&f,{default:()=>y(A,{suspensible:!0,onResolve:()=>{T(r)}},{default:()=>y(U,{layoutProps:w(s.attrs,o.meta.layoutProps??{},{ref:i}),key:a.value||void 0,name:a.value,shouldProvide:!e.name,isRenderingNewLayout:m=>m!==k&&m===a.value,hasTransition:!!f},s.slots)})}).default()}}}),U=d({name:"NuxtLayoutProvider",inheritAttrs:!1,props:{name:{type:[String,Boolean]},layoutProps:{type:Object},hasTransition:{type:Boolean},shouldProvide:{type:Boolean},isRenderingNewLayout:{type:Function,required:!0}},setup(e,s){const t=e.name;e.shouldProvide&&R(E,{isCurrent:o=>t===!1||t===(o.meta.layout??g(o.path).appLayout??"default")});const u=v(c);if(u&&u===P()){const o=L(),a={};for(const i in o){const r=i;Object.defineProperty(a,r,{enumerable:!0,get:()=>e.isRenderingNewLayout(e.name)?o[r]:u[r]})}R(c,M(a))}return()=>!t||typeof t=="string"&&!(t in l)?s.slots.default?.():y(C,{key:t,layoutProps:e.layoutProps,name:t},s.slots)}});export{q as _};
